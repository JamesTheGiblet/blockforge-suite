<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockForge - Image Studio</title>
    <meta name="description" content="Convert images into LEGO mosaics with Forge Theory optimization">
    <script>
        if (window.location.protocol !== 'file:') {
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = '../../manifest.json';
            document.head.appendChild(link);
        }
    </script>
    <meta name="theme-color" content="#004E89">
    <link rel="icon" type="image/png" href="../../public/icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #004E89;
            --bg-gradient-end: #003560;
            --container-bg: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --heading-color: #004E89;
            --accent-color: #FF6B35;
            --border-color: #dddddd;
            --input-bg: #ffffff;
            --panel-bg: #f0f4f8;
            --tips-bg: #fff8f0;
        }

        [data-theme="dark"] {
            --bg-gradient-start: #121212;
            --bg-gradient-end: #1e1e1e;
            --container-bg: #1e1e1e;
            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --heading-color: #64b5f6;
            --accent-color: #FF8C61;
            --border-color: #444444;
            --input-bg: #2d2d2d;
            --panel-bg: #262626;
            --tips-bg: #2d2620;
        }

        html {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            padding: 20px;
            color: var(--text-primary);
        }

        .header-bar {
            max-width: 1200px;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #FF6B35;
        }

        .header-title {
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .header-title .forge {
            color: #FF6B35;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: var(--heading-color);
            margin-bottom: 10px;
            font-size: 32px;
        }

        h1 .forge {
            color: var(--accent-color);
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 16px;
        }

        /* Forge Theory Panel */
        .forge-theory-panel {
            background: linear-gradient(135deg, var(--heading-color) 0%, var(--bg-gradient-end) 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }

        .forge-theory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .forge-theory-title {
            font-size: 18px;
            font-weight: 700;
        }

        .forge-toggle-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .forge-toggle-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
        }

        .forge-theory-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .forge-theory-content.active {
            max-height: 1000px;
        }

        .forge-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .forge-stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .forge-stat-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .forge-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
        }

        .forge-explanation {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid var(--accent-color);
            font-size: 14px;
            line-height: 1.6;
        }

        .forge-formula {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            margin: 10px 0;
            text-align: center;
            color: var(--accent-color);
        }

        .upload-section {
            border: 3px dashed var(--heading-color);
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            background: var(--panel-bg);
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            filter: brightness(0.95);
            border-color: var(--accent-color);
        }

        .upload-section.drag-over {
            background: var(--input-bg);
            border-color: var(--accent-color);
        }

        #fileInput {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .controls {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: var(--heading-color);
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            background: var(--accent-color);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--heading-color) 0%, var(--bg-gradient-end) 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 78, 137, 0.4);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 78, 137, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--accent-color);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        }

        button.secondary:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        button.tertiary {
            background: #6b7280;
        }

        .export-instructions-btn {
            margin-top: 10px;
            display: none;
        }

        .preview-section {
            margin-top: 30px;
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .preview-grid {
            display: grid;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (min-width: 640px) {
            .preview-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        .preview-box {
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            background: var(--panel-bg);
        }

        .preview-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--heading-color);
            font-size: 14px;
        }

        .canvas-container {
            width: 100%;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--container-bg);
            border-radius: 8px;
            overflow: hidden;
            padding: 10px;
        }

        canvas {
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            border: 2px solid var(--border-color);
            border-radius: 4px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 12px;
            border: 2px solid var(--heading-color);
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--heading-color);
        }

        .color-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: var(--container-bg);
            border-radius: 8px;
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 8px;
            background: var(--panel-bg);
            border-radius: 8px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
        }

        .color-info {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .color-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .color-count {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
        }

        .tips-box {
            background: var(--tips-bg);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent-color);
        }

        .tips-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--heading-color);
        }

        .tips-box ul {
            font-size: 13px;
            color: var(--text-primary);
            line-height: 1.6;
            padding-left: 20px;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        @media (max-width: 640px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 24px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .header-bar {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-left: auto;
        }
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* Loading Spinner */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        .loading-text {
            color: white;
            font-size: 20px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Falling Bricks */
        #falling-bricks-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1; /* Behind content */
            overflow: hidden;
        }

        .falling-brick {
            position: absolute;
            border-radius: 2px;
            opacity: 0.2;
            background-image: radial-gradient(rgba(0,0,0,0.2) 25%, transparent 25%);
            background-size: 20px 20px;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        /* Ensure main content is above bricks */
        .container, .header-bar {
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="falling-bricks-container"></div>
    <div class="header-bar">
        <a href="../../index.html" class="back-btn">‚Üê Back to BlockForge</a>
        <div class="header-title">BLOCK<span class="forge">FORGE</span> - Image Studio</div>
        <button class="theme-toggle" id="themeToggle" aria-label="Toggle Dark Mode">
            <span id="themeIcon">üåô</span>
        </button>
    </div>

    <div class="container">
        <h1>üñºÔ∏è Image <span class="forge">Studio</span></h1>
        <p class="subtitle">Convert images into LEGO mosaics with Forge Theory optimization</p>

        <!-- Forge Theory Panel -->
        <div class="forge-theory-panel">
            <div class="forge-theory-header">
                <div class="forge-theory-title">üî¨ Powered by Forge Theory</div>
                <button class="forge-toggle-btn" onclick="toggleForgeTheory()">Show Mathematics</button>
            </div>
            <div class="forge-theory-content" id="forgeTheoryContent">
                <div class="forge-stats-grid" id="forgeStatsGrid">
                    <div class="forge-stat">
                        <div class="forge-stat-label">Information Retention</div>
                        <div class="forge-stat-value" id="forgeRetention">-</div>
                    </div>
                    <div class="forge-stat">
                        <div class="forge-stat-label">Perceptual Quality</div>
                        <div class="forge-stat-value" id="forgeQuality">-</div>
                    </div>
                    <div class="forge-stat">
                        <div class="forge-stat-label">Optimization Level</div>
                        <div class="forge-stat-value" id="forgeOptimization">-</div>
                    </div>
                    <div class="forge-stat">
                        <div class="forge-stat-label">Decay Constant (Œª)</div>
                        <div class="forge-stat-value" id="forgeDecay">0.15</div>
                    </div>
                </div>
                <div class="forge-explanation">
                    <strong>How Forge Theory Optimizes Your Mosaic:</strong>
                    <div class="forge-formula">I(t) = I‚ÇÄ ¬∑ e<sup>-Œªt</sup></div>
                    <p>BlockForge uses exponential decay mathematics to minimize information loss during quantization. As your image is converted from millions of colors to ~50 LEGO colors, the Forge engine calculates optimal color mappings that preserve maximum perceptual quality while ensuring practical buildability.</p>
                    <p style="margin-top: 10px;"><strong>Current Settings:</strong> Your mosaic will retain approximately <span id="forgeRetentionText">-</span> of the original image's information content, resulting in a perceptual quality score of <span id="forgeQualityText">-</span>/100.</p>
                </div>
            </div>
        </div>

        <div class="tips-box">
            <div class="tips-title">üí° Tips for Best Results:</div>
            <ul>
                <li>Use <strong>high contrast</strong> images with clear subjects</li>
                <li>Simple compositions work better than complex scenes</li>
                <li>Portraits: 48+ tiles wide | Landscapes: 64+ tiles wide</li>
                <li>Boost saturation for vibrant colors</li>
                <li>Enable dithering for smooth gradients</li>
                <li>Auto-enhance for quick optimization</li>
            </ul>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üì∏</div>
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">
                Click or drag image here
            </div>
            <div style="font-size: 14px; color: #666;">
                Supports JPG, PNG, GIF
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="controls">
            <div class="control-group">
                <label>
                    Tile Width: <span class="value-display" id="widthValue">32</span> tiles
                </label>
                <input type="range" id="widthSlider" min="16" max="128" value="32" step="1" title="Adjust tile width">
            </div>

            <div class="control-group">
                <label>
                    Contrast: <span class="value-display" id="contrastValue">100</span>%
                </label>
                <input type="range" id="contrastSlider" min="50" max="200" value="100" step="5" title="Adjust contrast">
            </div>

            <div class="control-group">
                <label>
                    Brightness: <span class="value-display" id="brightnessValue">100</span>%
                </label>
                <input type="range" id="brightnessSlider" min="50" max="150" value="100" step="5" title="Adjust brightness">
            </div>

            <div class="control-group">
                <label>
                    Saturation: <span class="value-display" id="saturationValue">100</span>%
                </label>
                <input type="range" id="saturationSlider" min="0" max="200" value="100" step="10" title="Adjust saturation">
            </div>

            <div class="control-group">
                <label>
                    Sharpness: <span class="value-display" id="sharpnessValue">0</span>
                </label>
                <input type="range" id="sharpnessSlider" min="0" max="100" value="0" step="10" title="Adjust sharpness">
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="ditherCheckbox" style="width: auto; height: 20px;">
                    Enable Dithering (smoother gradients)
                </label>
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="autoContrastCheckbox" style="width: auto; height: 20px;">
                    Auto-enhance contrast
                </label>
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="gridCheckbox" style="width: auto; height: 20px;">
                    Show Grid (visualize individual tiles)
                </label>
            </div>

            <div class="control-group">
                <label for="backgroundColorSelect">
                    Background/Baseplate Color
                </label>
                <select id="backgroundColorSelect" title="Background or Baseplate Color">
                    <option value="none">None (transparent)</option>
                    <option value="White">White</option>
                    <option value="Black">Black</option>
                    <option value="Light Bluish Gray" selected>Light Bluish Gray (most common)</option>
                    <option value="Dark Bluish Gray">Dark Bluish Gray</option>
                    <option value="Tan">Tan</option>
                    <option value="Dark Tan">Dark Tan</option>
                    <option value="Sand Blue">Sand Blue</option>
                    <option value="Sand Green">Sand Green</option>
                    <option value="Blue">Blue</option>
                    <option value="Green">Green</option>
                    <option value="Red">Red</option>
                    <option value="Yellow">Yellow</option>
                </select>
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="removeBackgroundCheckbox" style="width: auto; height: 20px;">
                    Remove Background (Flood Fill)
                </label>
                <div id="bgToleranceControl" style="display: none; margin-top: 10px;">
                    <label style="font-size: 12px;">Tolerance: <span id="toleranceValue">30</span></label>
                    <input type="range" id="toleranceSlider" min="1" max="100" value="30" step="1">
                </div>
                <div id="detectedBgInfo" style="display: none; margin-top: 8px; padding: 10px; background: var(--panel-bg); border-radius: 8px; font-size: 13px;">
                    <strong>Detected:</strong> <span id="detectedBgColor">-</span> (Edge Average)
                </div>
            </div>

            <button id="resetBtn" class="tertiary" style="margin-bottom: 10px;">Reset All Settings</button>
            <button id="generateBtn" disabled>Generate LEGO Mosaic</button>
            <button id="downloadBtn" class="secondary" style="margin-top: 10px; display: none;">
                üì• Download LEGO Mosaic
            </button>
            <button id="exportPartsBtn" class="secondary" style="margin-top: 10px; display: none;">
                üìã Export Parts List (CSV)
            </button>
            <button id="exportInstructionsBtn" class="secondary export-instructions-btn">
                üìñ Export Assembly Instructions
            </button>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="preview-grid">
                <div class="preview-box">
                    <div class="preview-title">Original (Resized)</div>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>

                <div class="preview-box">
                    <div class="preview-title">LEGO Mosaic</div>
                    <div class="canvas-container">
                        <canvas id="legoCanvas"></canvas>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Dimensions</div>
                    <div class="stat-value" id="dimensions">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Tiles</div>
                    <div class="stat-value" id="totalTiles">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Unique Colors</div>
                    <div class="stat-value" id="uniqueColors">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Physical Size</div>
                    <div class="stat-value" id="physicalSize">-</div>
                </div>
            </div>

            <div class="preview-box" style="margin-top: 20px;">
                <div class="preview-title">Color Breakdown</div>
                <div class="color-list" id="colorList"></div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Forging Mosaic...</div>
    </div>

    <script src="../../shared/blockforge-core.js"></script>
    <script>
        // Initialize Forge Theory engine
        const forgeEngine = new ForgeTheory();
        
        // LEGO Color Palette
        const LEGO_COLORS = {
            "Red": [201, 26, 9],
            "Blue": [0, 85, 191],
            "Yellow": [255, 205, 3],
            "Green": [0, 158, 96],
            "White": [255, 255, 255],
            "Black": [5, 19, 29],
            "Light Bluish Gray": [156, 163, 168],
            "Dark Bluish Gray": [99, 95, 97],
            "Reddish Brown": [88, 42, 18],
            "Dark Brown": [53, 33, 0],
            "Dark Tan": [137, 125, 98],
            "Medium Brown": [115, 84, 58],
            "Reddish Orange": [202, 76, 11],
            "Orange": [255, 127, 0],
            "Dark Orange": [168, 61, 21],
            "Dark Red": [114, 0, 18],
            "Coral": [255, 109, 119],
            "Dark Pink": [222, 55, 139],
            "Bright Pink": [255, 151, 204],
            "Medium Dark Pink": [247, 133, 177],
            "Purple": [129, 0, 123],
            "Dark Purple": [63, 26, 86],
            "Magenta": [146, 57, 120],
            "Medium Lavender": [172, 120, 186],
            "Lavender": [205, 164, 222],
            "Dark Blue": [0, 32, 96],
            "Medium Blue": [97, 175, 255],
            "Medium Azure": [54, 174, 191],
            "Light Aqua": [204, 255, 255],
            "Dark Azure": [70, 155, 195],
            "Bright Light Blue": [159, 195, 233],
            "Sand Blue": [112, 129, 154],
            "Dark Green": [0, 69, 26],
            "Sand Green": [112, 142, 124],
            "Olive Green": [122, 124, 69],
            "Lime": [190, 214, 0],
            "Yellowish Green": [226, 249, 154],
            "Tan": [222, 198, 156],
            "Light Nougat": [254, 204, 176],
            "Medium Nougat": [170, 125, 85],
            "Nougat": [204, 142, 105],
            "Dark Nougat": [170, 104, 66],
            "Flat Silver": [140, 140, 140],
            "Metallic Silver": [140, 140, 140],
            "Pearl Gold": [220, 188, 129]
        };

        // State
        let uploadedImage = null;
        let currentTileWidth = 32;
        let contrast = 100;
        let brightness = 100;
        let saturation = 100;
        let sharpness = 0;
        let enableDither = false;
        let autoContrast = false;
        let showGrid = false;
        let backgroundColor = 'Light Bluish Gray';
        let removeBackground = false;
        let bgTolerance = 30;
        let detectedBackgroundColor = null;
        let tileMap = [];
        let forgeTheoryVisible = false;

        // Elements
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const widthSlider = document.getElementById('widthSlider');
        const widthValue = document.getElementById('widthValue');
        const contrastSlider = document.getElementById('contrastSlider');
        const contrastValue = document.getElementById('contrastValue');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const saturationSlider = document.getElementById('saturationSlider');
        const saturationValue = document.getElementById('saturationValue');
        const sharpnessSlider = document.getElementById('sharpnessSlider');
        const sharpnessValue = document.getElementById('sharpnessValue');
        const ditherCheckbox = document.getElementById('ditherCheckbox');
        const autoContrastCheckbox = document.getElementById('autoContrastCheckbox');
        const gridCheckbox = document.getElementById('gridCheckbox');
        const backgroundColorSelect = document.getElementById('backgroundColorSelect');
        const removeBackgroundCheckbox = document.getElementById('removeBackgroundCheckbox');
        const bgToleranceControl = document.getElementById('bgToleranceControl');
        const toleranceSlider = document.getElementById('toleranceSlider');
        const toleranceValue = document.getElementById('toleranceValue');
        const detectedBgInfo = document.getElementById('detectedBgInfo');
        const detectedBgColor = document.getElementById('detectedBgColor');
        const generateBtn = document.getElementById('generateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const exportPartsBtn = document.getElementById('exportPartsBtn');
        const exportInstructionsBtn = document.getElementById('exportInstructionsBtn');
        const previewSection = document.getElementById('previewSection');
        const originalCanvas = document.getElementById('originalCanvas');
        const legoCanvas = document.getElementById('legoCanvas');

        // Forge Theory toggle
        function toggleForgeTheory() {
            const content = document.getElementById('forgeTheoryContent');
            const btn = document.querySelector('.forge-toggle-btn');
            forgeTheoryVisible = !forgeTheoryVisible;
            
            if (forgeTheoryVisible) {
                content.classList.add('active');
                btn.textContent = 'Hide Mathematics';
            } else {
                content.classList.remove('active');
                btn.textContent = 'Show Mathematics';
            }
        }

        function updateForgeTheoryStats() {
            if (!uploadedImage) return;

            const aspectRatio = uploadedImage.height / uploadedImage.width;
            const targetHeight = Math.round(currentTileWidth * aspectRatio);
            
            // Calculate Forge Theory optimization
            const report = forgeEngine.generateOptimizationReport({
                contentType: 'image',
                quality: 'medium',
                width: currentTileWidth,
                height: targetHeight,
                depth: 1
            });

            // Update stats
            document.getElementById('forgeRetention').textContent = report.retention.percentage + '%';
            document.getElementById('forgeQuality').textContent = report.retention.perceptual;
            document.getElementById('forgeOptimization').textContent = report.optimization.quantizationSteps;
            document.getElementById('forgeDecay').textContent = report.optimization.decayConstant.toFixed(3);
            
            document.getElementById('forgeRetentionText').textContent = report.retention.percentage + '%';
            document.getElementById('forgeQualityText').textContent = report.retention.perceptual;
        }

        // Upload handlers
        uploadSection.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('drag-over');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('drag-over');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        widthSlider.addEventListener('input', (e) => {
            currentTileWidth = parseInt(e.target.value);
            widthValue.textContent = currentTileWidth;
            updateForgeTheoryStats();
        });

        contrastSlider.addEventListener('input', (e) => {
            contrast = parseInt(e.target.value);
            contrastValue.textContent = contrast;
        });

        brightnessSlider.addEventListener('input', (e) => {
            brightness = parseInt(e.target.value);
            brightnessValue.textContent = brightness;
        });

        saturationSlider.addEventListener('input', (e) => {
            saturation = parseInt(e.target.value);
            saturationValue.textContent = saturation;
        });

        sharpnessSlider.addEventListener('input', (e) => {
            sharpness = parseInt(e.target.value);
            sharpnessValue.textContent = sharpness;
        });

        ditherCheckbox.addEventListener('change', (e) => {
            enableDither = e.target.checked;
        });

        autoContrastCheckbox.addEventListener('change', (e) => {
            autoContrast = e.target.checked;
        });

        gridCheckbox.addEventListener('change', (e) => {
            showGrid = e.target.checked;
            if (uploadedImage && previewSection.classList.contains('active')) {
                generateMosaic();
            }
        });

        backgroundColorSelect.addEventListener('change', (e) => {
            backgroundColor = e.target.value;
            if (uploadedImage && previewSection.classList.contains('active')) {
                generateMosaic();
            }
        });

        removeBackgroundCheckbox.addEventListener('change', (e) => {
            removeBackground = e.target.checked;
            if (removeBackground) {
                backgroundColor = 'none';
                backgroundColorSelect.value = 'none';
                backgroundColorSelect.disabled = true;
                bgToleranceControl.style.display = 'block';
            } else {
                backgroundColorSelect.disabled = false;
                bgToleranceControl.style.display = 'none';
            }
            if (uploadedImage && previewSection.classList.contains('active')) {
                generateMosaic();
            }
        });

        toleranceSlider.addEventListener('input', (e) => {
            bgTolerance = parseInt(e.target.value);
            toleranceValue.textContent = bgTolerance;
            if (uploadedImage && previewSection.classList.contains('active')) {
                generateMosaic();
            }
        });

        generateBtn.addEventListener('click', generateMosaic);

        downloadBtn.addEventListener('click', () => {
            const downloadCanvas = document.createElement('canvas');
            const scale = 10;
            
            downloadCanvas.width = legoCanvas.width * scale;
            downloadCanvas.height = legoCanvas.height * scale;
            
            const ctx = downloadCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(legoCanvas, 0, 0, downloadCanvas.width, downloadCanvas.height);
            
            if (showGrid) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                
                for (let x = 0; x <= legoCanvas.width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * scale, 0);
                    ctx.lineTo(x * scale, downloadCanvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= legoCanvas.height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * scale);
                    ctx.lineTo(downloadCanvas.width, y * scale);
                    ctx.stroke();
                }
            }
            
            downloadCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `blockforge-mosaic-${legoCanvas.width}x${legoCanvas.height}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        });

        exportPartsBtn.addEventListener('click', () => {
            if (tileMap.length === 0) return;

            const colorCounts = {};
            let removedTiles = 0;
            tileMap.forEach(row => {
                row.forEach(colorName => {
                    if (colorName === null) {
                        removedTiles++;
                    } else {
                        colorCounts[colorName] = (colorCounts[colorName] || 0) + 1;
                    }
                });
            });

            const totalGridSpaces = tileMap.length * tileMap[0].length;
            const actualTiles = totalGridSpaces - removedTiles;
            const baseplateInfo = calculateBaseplates(tileMap[0].length, tileMap.length, backgroundColor);

            const tilePrices = {
                'White': 0.02, 'Black': 0.02, 'Red': 0.03, 'Blue': 0.03, 'Yellow': 0.03,
                'Green': 0.03, 'Light Bluish Gray': 0.02, 'Dark Bluish Gray': 0.03,
                'Tan': 0.04, 'Dark Tan': 0.04, 'Light Nougat': 0.04, 'Nougat': 0.05,
                'Medium Nougat': 0.05, 'Dark Nougat': 0.05, 'Pearl Gold': 0.06,
                'Coral': 0.05, 'Dark Red': 0.04, 'Dark Orange': 0.04, 'Orange': 0.03,
                'Bright Pink': 0.05, 'Medium Dark Pink': 0.05, 'Dark Pink': 0.06,
                'Lavender': 0.05, 'Medium Lavender': 0.05, 'Purple': 0.04,
                'Dark Purple': 0.05, 'Magenta': 0.05, 'Sand Blue': 0.04,
                'Sand Green': 0.04, 'Bright Light Blue': 0.04, 'Medium Azure': 0.05,
                'Light Aqua': 0.05, 'Dark Azure': 0.05, 'Dark Blue': 0.03,
                'Medium Blue': 0.04, 'Dark Green': 0.04, 'Olive Green': 0.05,
                'Lime': 0.04, 'Yellowish Green': 0.05, 'Reddish Brown': 0.04,
                'Dark Brown': 0.04, 'Medium Brown': 0.05, 'Reddish Orange': 0.04,
                'Flat Silver': 0.06, 'Metallic Silver': 0.07
            };

            let totalCost = 0;

            let csv = 'BLOCKFORGE IMAGE STUDIO - PARTS LIST\n';
            csv += 'Generated by Forge Theory optimization engine\n\n';
            csv += 'TILES (1x1 with groove - Part 3070b)\n';
            csv += 'Color Name,Quantity,Part Number,Est. Price Each,Est. Total,RGB Values\n';
            
            const sortedColors = Object.entries(colorCounts).sort((a, b) => b[1] - a[1]);
            sortedColors.forEach(([colorName, count]) => {
                const rgb = LEGO_COLORS[colorName];
                const priceEach = tilePrices[colorName] || 0.05;
                const colorTotal = count * priceEach;
                totalCost += colorTotal;
                csv += `"${colorName}",${count},"3070b","$${priceEach.toFixed(3)}","$${colorTotal.toFixed(2)}","rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})"\n`;
            });

            csv += '\n';
            csv += 'BASEPLATE REQUIREMENTS\n';
            csv += 'Type,Quantity,Part Number,Est. Price Each,Est. Total,Notes\n';
            
            baseplateInfo.forEach(item => {
                const itemTotal = item.quantity * item.price;
                totalCost += itemTotal;
                csv += `"${item.type}",${item.quantity},"${item.part}","$${item.price.toFixed(2)}","$${itemTotal.toFixed(2)}","${item.notes}"\n`;
            });

            csv += '\n';
            csv += 'BUILD SUMMARY\n';
            csv += `Total Tiles,${actualTiles}\n`;
            if (removedTiles > 0) {
                const label = backgroundColor !== 'none' ? 'Exposed Baseplate' : 'Background Removed';
                csv += `${label},${removedTiles} tiles (${((removedTiles / totalGridSpaces) * 100).toFixed(1)}%)\n`;
                csv += `Grid Spaces,${totalGridSpaces}\n`;
            }
            csv += `Unique Tile Colors,${Object.keys(colorCounts).length}\n`;
            csv += `Width,${tileMap[0].length} tiles\n`;
            csv += `Height,${tileMap.length} tiles\n`;
            csv += `Physical Width,${(tileMap[0].length * 8 / 10).toFixed(1)} cm\n`;
            csv += `Physical Height,${(tileMap.length * 8 / 10).toFixed(1)} cm\n`;
            csv += `Background Color,${backgroundColor}\n`;
            csv += '\n';
            csv += 'FORGE THEORY OPTIMIZATION\n';
            const report = forgeEngine.generateOptimizationReport({
                contentType: 'image',
                quality: 'medium',
                width: tileMap[0].length,
                height: tileMap.length,
                depth: 1
            });
            csv += `Information Retention,${report.retention.percentage}%\n`;
            csv += `Perceptual Quality,${report.retention.perceptual}/100\n`;
            csv += `Decay Constant (Œª),${report.optimization.decayConstant}\n`;
            csv += '\n';
            csv += 'COST ESTIMATE (USD)\n';
            csv += `Tiles Total,"$${(totalCost - baseplateInfo.reduce((sum, item) => sum + (item.quantity * item.price), 0)).toFixed(2)}"\n`;
            csv += `Baseplates Total,"$${baseplateInfo.reduce((sum, item) => sum + (item.quantity * item.price), 0).toFixed(2)}"\n`;
            csv += `Estimated Total,"$${totalCost.toFixed(2)}"\n`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blockforge-parts-${tileMap[0].length}x${tileMap.length}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        function calculateBaseplates(width, height, bgColor) {
            const widthStuds = Math.ceil(width * 0.8);
            const heightStuds = Math.ceil(height * 0.8);
            
            const baseplates = [];
            
            if (bgColor === 'none') {
                baseplates.push({
                    type: 'No baseplate (transparent background)',
                    quantity: 0,
                    part: 'N/A',
                    price: 0,
                    notes: 'Mount tiles directly to surface'
                });
            } else {
                const cols = Math.ceil(widthStuds / 32);
                const rows = Math.ceil(heightStuds / 32);
                const count32x32 = cols * rows;
                
                baseplates.push({
                    type: `32x32 Baseplate (${bgColor})`,
                    quantity: count32x32,
                    part: '3811',
                    price: 8.50,
                    notes: `Arrange in ${cols}x${rows} grid`
                });

                if (widthStuds <= 48 && heightStuds <= 48) {
                    baseplates.push({
                        type: `48x48 Baseplate (${bgColor}) - Alternative`,
                        quantity: 1,
                        part: '4186',
                        price: 18.00,
                        notes: 'Single large baseplate option'
                    });
                }
            }
            
            return baseplates;
        }

        exportInstructionsBtn.addEventListener('click', () => {
            if (tileMap.length === 0) return;

            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockForge Assembly Instructions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #004E89;
            border-bottom: 3px solid #FF6B35;
            padding-bottom: 10px;
        }
        .forge { color: #FF6B35; }
        .info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        .info-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
        }
        .info-label {
            font-weight: bold;
            color: #666;
            font-size: 12px;
        }
        .info-value {
            font-size: 18px;
            color: #004E89;
            margin-top: 5px;
        }
        .row {
            background: white;
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .row-header {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 10px;
            color: #FF6B35;
        }
        .tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .tile {
            width: 30px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 3px;
            position: relative;
        }
        .tile:hover::after {
            content: attr(data-color);
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 11px;
            z-index: 10;
        }
        .color-legend {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .legend-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .legend-info {
            flex-grow: 1;
        }
        .legend-name {
            font-weight: bold;
            font-size: 13px;
        }
        .legend-count {
            font-size: 11px;
            color: #666;
        }
        @media print {
            body { background: white; }
            .row { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <h1>üß± BLOCK<span class="forge">FORGE</span> Assembly Instructions</h1>
    
    <div class="info">
        <h2 style="margin-top: 0;">Build Specifications</h2>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Dimensions</div>
                <div class="info-value">${tileMap[0].length} √ó ${tileMap.length} tiles</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Tiles</div>
                <div class="info-value">${(tileMap.length * tileMap[0].length).toLocaleString()}</div>
            </div>
            <div class="info-item">
                <div class="info-label">Physical Size</div>
                <div class="info-value">${(tileMap[0].length * 8 / 10).toFixed(1)} √ó ${(tileMap.length * 8 / 10).toFixed(1)} cm</div>
            </div>
            <div class="info-item">
                <div class="info-label">Build Time</div>
                <div class="info-value">~${Math.round(tileMap.length * tileMap[0].length / 100)} hours</div>
            </div>
        </div>
    </div>

    <div class="color-legend">
        <h2 style="margin-top: 0;">Color Legend</h2>
        <div class="legend-grid">`;

            const colorCounts = {};
            tileMap.forEach(row => {
                row.forEach(colorName => {
                    if (colorName !== null) {
                        colorCounts[colorName] = (colorCounts[colorName] || 0) + 1;
                    }
                });
            });

            const sortedColors = Object.entries(colorCounts).sort((a, b) => b[1] - a[1]);
            sortedColors.forEach(([colorName, count]) => {
                const rgb = LEGO_COLORS[colorName];
                html += `
            <div class="legend-item">
                <div class="legend-swatch" style="background: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]});"></div>
                <div class="legend-info">
                    <div class="legend-name">${colorName}</div>
                    <div class="legend-count">${count} tiles</div>
                </div>
            </div>`;
            });

            html += `
        </div>
    </div>

    <h2>Assembly Instructions (Bottom to Top)</h2>
    <p style="background: #fff8f0; padding: 15px; border-radius: 8px; border-left: 4px solid #FF6B35;">
        <strong>üí° Tip:</strong> Build from bottom (Row 1) to top. Each row shows tiles from left to right. 
        Hover over tiles to see the color name.
    </p>
`;

            for (let y = tileMap.length - 1; y >= 0; y--) {
                html += `
    <div class="row">
        <div class="row-header">Row ${tileMap.length - y} (of ${tileMap.length})</div>
        <div class="tiles">`;
                
                tileMap[y].forEach((colorName, x) => {
                    if (colorName === null) {
                        const label = backgroundColor !== 'none' ? `No tile (${backgroundColor} baseplate)` : 'No tile (background removed)';
                        html += `<div class="tile" style="background: repeating-linear-gradient(45deg, #f0f0f0, #f0f0f0 5px, #e0e0e0 5px, #e0e0e0 10px); border: 1px dashed #ccc;" data-color="${label}" title="${label}"></div>`;
                    } else {
                        const rgb = LEGO_COLORS[colorName];
                        html += `<div class="tile" style="background: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]});" data-color="${colorName}" title="${colorName}"></div>`;
                    }
                });

                html += `
        </div>
    </div>`;
            }

            html += `
</body>
</html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blockforge-instructions-${tileMap[0].length}x${tileMap.length}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        resetBtn.addEventListener('click', () => {
            currentTileWidth = 32;
            contrast = 100;
            brightness = 100;
            saturation = 100;
            sharpness = 0;
            enableDither = false;
            autoContrast = false;
            showGrid = false;
            backgroundColor = 'Light Bluish Gray';
            removeBackground = false;

            widthSlider.value = 32;
            widthValue.textContent = 32;
            contrastSlider.value = 100;
            contrastValue.textContent = 100;
            brightnessSlider.value = 100;
            brightnessValue.textContent = 100;
            saturationSlider.value = 100;
            saturationValue.textContent = 100;
            sharpnessSlider.value = 0;
            sharpnessValue.textContent = 0;
            ditherCheckbox.checked = false;
            autoContrastCheckbox.checked = false;
            gridCheckbox.checked = false;
            backgroundColorSelect.value = 'Light Bluish Gray';
            backgroundColorSelect.disabled = false;
            removeBackgroundCheckbox.checked = false;
            bgToleranceControl.style.display = 'none';
            detectedBgInfo.style.display = 'none';
            
            updateForgeTheoryStats();
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    generateBtn.disabled = false;
                    uploadSection.innerHTML = `
                        <div style="font-size: 18px; font-weight: 600; color: var(--heading-color);">
                            ‚úì Image loaded
                        </div>
                        <div style="font-size: 14px; color: var(--text-secondary); margin-top: 8px;">
                            ${img.width} √ó ${img.height} pixels
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; opacity: 0.7;">
                            Click to change
                        </div>
                    `;
                    updateForgeTheoryStats();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function findClosestLegoColor(r, g, b) {
            let minDistance = Infinity;
            let closestColor = null;
            let closestRgb = null;

            for (const [name, rgb] of Object.entries(LEGO_COLORS)) {
                const distance = Math.sqrt(
                    Math.pow(r - rgb[0], 2) +
                    Math.pow(g - rgb[1], 2) +
                    Math.pow(b - rgb[2], 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = name;
                    closestRgb = rgb;
                }
            }

            return { name: closestColor, rgb: closestRgb };
        }

        function adjustContrast(value, factor) {
            return Math.max(0, Math.min(255, ((value - 128) * factor) + 128));
        }

        function adjustBrightness(value, factor) {
            return Math.max(0, Math.min(255, value * factor));
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function detectBackgroundColor(imageData, width, height) {
            const pixels = imageData.data;
            const samples = [];
            
            const corners = [
                [0, 0], [width - 1, 0], [0, height - 1], [width - 1, height - 1]
            ];
            
            const edgeSampleCount = 20;
            for (let i = 0; i < edgeSampleCount; i++) {
                const x = Math.floor((width * i) / edgeSampleCount);
                const y = Math.floor((height * i) / edgeSampleCount);
                samples.push([x, 0]);
                samples.push([x, height - 1]);
                samples.push([0, y]);
                samples.push([width - 1, y]);
            }
            
            corners.forEach(([x, y]) => samples.push([x, y]));
            
            const colorMap = {};
            const colorSums = {};
            samples.forEach(([x, y]) => {
                const idx = (y * width + x) * 4;
                const r = pixels[idx];
                const g = pixels[idx + 1];
                const b = pixels[idx + 2];
                const a = pixels[idx + 3];
                
                if (a < 128) return;
                
                const qr = Math.round(r / 16) * 16;
                const qg = Math.round(g / 16) * 16;
                const qb = Math.round(b / 16) * 16;
                const key = `${qr},${qg},${qb}`;
                
                colorMap[key] = (colorMap[key] || 0) + 1;
                
                if (!colorSums[key]) colorSums[key] = {r:0, g:0, b:0, count:0};
                colorSums[key].r += r;
                colorSums[key].g += g;
                colorSums[key].b += b;
                colorSums[key].count++;
            });
            
            let maxCount = 0;
            let bestKey = null;
            for (const [key, count] of Object.entries(colorMap)) {
                if (count > maxCount) {
                    maxCount = count;
                    bestKey = key;
                }
            }
            
            if (bestKey) {
                const sum = colorSums[bestKey];
                return [
                    Math.round(sum.r / sum.count),
                    Math.round(sum.g / sum.count),
                    Math.round(sum.b / sum.count)
                ];
            }
            return null;
        }

        function removeBackgroundFromImage(imageData, width, height, bgColor, tolerance = 30) {
            if (!bgColor) return;
            
            const pixels = imageData.data;
            const [bgR, bgG, bgB] = bgColor;
            
            // Flood Fill Algorithm (BFS)
            const maskMap = Array(height).fill().map(() => Array(width).fill(false));
            const visited = new Uint8Array(width * height);
            const queue = [];

            const matches = (idx) => {
                const r = pixels[idx];
                const g = pixels[idx + 1];
                const b = pixels[idx + 2];
                const dist = Math.sqrt((r-bgR)**2 + (g-bgG)**2 + (b-bgB)**2);
                return dist < tolerance;
            };

            // Seed from edges
            const addSeed = (x, y) => {
                const idx = (y * width + x) * 4;
                const vIdx = y * width + x;
                if (matches(idx) && !visited[vIdx]) {
                    queue.push(x, y);
                    visited[vIdx] = 1;
                    maskMap[y][x] = true;
                }
            };

            // Check all edges
            for(let x = 0; x < width; x++) { addSeed(x, 0); addSeed(x, height-1); }
            for(let y = 0; y < height; y++) { addSeed(0, y); addSeed(width-1, y); }

            // Process queue
            let head = 0;
            while(head < queue.length) {
                const cx = queue[head++];
                const cy = queue[head++];
                
                const neighbors = [[cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]];
                
                for(const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const vIdx = ny * width + nx;
                        if (!visited[vIdx]) {
                            const pIdx = vIdx * 4;
                            if (matches(pIdx)) {
                                visited[vIdx] = 1;
                                maskMap[ny][nx] = true;
                                queue.push(nx, ny);
                            }
                        }
                    }
                }
            }
            
            return maskMap;
        }

        function adjustSaturation(r, g, b, factor) {
            const [h, s, l] = rgbToHsl(r, g, b);
            const newS = Math.max(0, Math.min(1, s * factor));
            return hslToRgb(h, newS, l);
        }

        function applySharpness(imageData, width, height, amount) {
            if (amount === 0) return;
            
            const pixels = imageData.data;
            const copy = new Uint8ClampedArray(pixels);
            const factor = amount / 100;

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    for (let c = 0; c < 3; c++) {
                        const center = copy[idx + c];
                        const top = copy[((y - 1) * width + x) * 4 + c];
                        const bottom = copy[((y + 1) * width + x) * 4 + c];
                        const left = copy[(y * width + (x - 1)) * 4 + c];
                        const right = copy[(y * width + (x + 1)) * 4 + c];
                        
                        const sharpened = center * (1 + 4 * factor) - 
                                        (top + bottom + left + right) * factor;
                        pixels[idx + c] = Math.max(0, Math.min(255, sharpened));
                    }
                }
            }
        }

        function autoEnhanceContrast(imageData) {
            const pixels = imageData.data;
            let min = [255, 255, 255];
            let max = [0, 0, 0];

            for (let i = 0; i < pixels.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    min[c] = Math.min(min[c], pixels[i + c]);
                    max[c] = Math.max(max[c], pixels[i + c]);
                }
            }

            for (let i = 0; i < pixels.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    const range = max[c] - min[c];
                    if (range > 0) {
                        pixels[i + c] = ((pixels[i + c] - min[c]) / range) * 255;
                    }
                }
            }
        }

        function applyDithering(imageData, width, height, protectedColor = null) {
            const pixels = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldR = pixels[idx];
                    const oldG = pixels[idx + 1];
                    const oldB = pixels[idx + 2];

                    const { rgb } = findClosestLegoColor(oldR, oldG, oldB);

                    // If this pixel maps to the protected baseplate color, snap it and skip error diffusion
                    if (protectedColor && 
                        rgb[0] === protectedColor[0] && 
                        rgb[1] === protectedColor[1] && 
                        rgb[2] === protectedColor[2]) {
                        
                        pixels[idx] = rgb[0];
                        pixels[idx + 1] = rgb[1];
                        pixels[idx + 2] = rgb[2];
                        continue;
                    }

                    pixels[idx] = rgb[0];
                    pixels[idx + 1] = rgb[1];
                    pixels[idx + 2] = rgb[2];

                    const errR = oldR - rgb[0];
                    const errG = oldG - rgb[1];
                    const errB = oldB - rgb[2];

                    const distribute = (xOffset, yOffset, factor) => {
                        const nx = x + xOffset;
                        const ny = y + yOffset;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = (ny * width + nx) * 4;
                            pixels[nIdx] = Math.max(0, Math.min(255, pixels[nIdx] + errR * factor));
                            pixels[nIdx + 1] = Math.max(0, Math.min(255, pixels[nIdx + 1] + errG * factor));
                            pixels[nIdx + 2] = Math.max(0, Math.min(255, pixels[nIdx + 2] + errB * factor));
                        }
                    };

                    distribute(1, 0, 7/16);
                    distribute(-1, 1, 3/16);
                    distribute(0, 1, 5/16);
                    distribute(1, 1, 1/16);
                }
            }
        }

        function drawGrid(canvas, width, height) {
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;

            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        function generateMosaic() {
            if (!uploadedImage) return;

            // Show loading spinner
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.add('active');

            // Use setTimeout to allow UI to update before heavy processing
            setTimeout(() => {
                previewSection.classList.add('active');

                const targetWidth = currentTileWidth;
                const aspectRatio = uploadedImage.height / uploadedImage.width;
                const targetHeight = Math.round(targetWidth * aspectRatio);

                originalCanvas.width = targetWidth;
                originalCanvas.height = targetHeight;
                legoCanvas.width = targetWidth;
                legoCanvas.height = targetHeight;

                const displayScale = Math.max(300 / Math.max(targetWidth, targetHeight), 1);
                const displayWidth = targetWidth * displayScale;
                const displayHeight = targetHeight * displayScale;
                
                originalCanvas.style.width = `${displayWidth}px`;
                originalCanvas.style.height = `${displayHeight}px`;
                legoCanvas.style.width = `${displayWidth}px`;
                legoCanvas.style.height = `${displayHeight}px`;

                const originalCtx = originalCanvas.getContext('2d');
                const legoCtx = legoCanvas.getContext('2d');

                if (backgroundColor !== 'none') {
                    const bgRgb = LEGO_COLORS[backgroundColor];
                    originalCtx.fillStyle = `rgb(${bgRgb[0]}, ${bgRgb[1]}, ${bgRgb[2]})`;
                    originalCtx.fillRect(0, 0, targetWidth, targetHeight);
                    legoCtx.fillStyle = `rgb(${bgRgb[0]}, ${bgRgb[1]}, ${bgRgb[2]})`;
                    legoCtx.fillRect(0, 0, targetWidth, targetHeight);
                }

                originalCtx.imageSmoothingEnabled = false;
                originalCtx.drawImage(uploadedImage, 0, 0, targetWidth, targetHeight);

                const imageData = originalCtx.getImageData(0, 0, targetWidth, targetHeight);
                const pixels = imageData.data;

                const contrastFactor = contrast / 100;
                const brightnessFactor = brightness / 100;
                const saturationFactor = saturation / 100;

                if (autoContrast) {
                    autoEnhanceContrast(imageData);
                }

                for (let i = 0; i < pixels.length; i += 4) {
                    let r = pixels[i];
                    let g = pixels[i + 1];
                    let b = pixels[i + 2];

                    r = adjustContrast(r, contrastFactor);
                    g = adjustContrast(g, contrastFactor);
                    b = adjustContrast(b, contrastFactor);

                    r = adjustBrightness(r, brightnessFactor);
                    g = adjustBrightness(g, brightnessFactor);
                    b = adjustBrightness(b, brightnessFactor);

                    [r, g, b] = adjustSaturation(r, g, b, saturationFactor);

                    pixels[i] = r;
                    pixels[i + 1] = g;
                    pixels[i + 2] = b;
                }

                if (sharpness > 0) {
                    applySharpness(imageData, targetWidth, targetHeight, sharpness);
                }

                let backgroundMask = null;
                if (removeBackground) {
                    detectedBackgroundColor = detectBackgroundColor(imageData, targetWidth, targetHeight);
                    if (detectedBackgroundColor) {
                        backgroundMask = removeBackgroundFromImage(imageData, targetWidth, targetHeight, detectedBackgroundColor, bgTolerance);
                        
                        detectedBgInfo.style.display = 'block';
                        detectedBgColor.textContent = `RGB(${detectedBackgroundColor[0]}, ${detectedBackgroundColor[1]}, ${detectedBackgroundColor[2]})`;
                        detectedBgColor.style.background = `rgb(${detectedBackgroundColor[0]}, ${detectedBackgroundColor[1]}, ${detectedBackgroundColor[2]})`;
                        detectedBgColor.style.padding = '4px 8px';
                        detectedBgColor.style.borderRadius = '4px';
                        detectedBgColor.style.color = (detectedBackgroundColor[0] + detectedBackgroundColor[1] + detectedBackgroundColor[2]) > 384 ? '#000' : '#fff';
                    }
                } else {
                    detectedBgInfo.style.display = 'none';
                }

                originalCtx.putImageData(imageData, 0, 0);

                const processedData = originalCtx.getImageData(0, 0, targetWidth, targetHeight);
                const processedPixels = processedData.data;

                const colorCounts = {};
                tileMap = [];

                if (enableDither) {
                    let baseplateRgb = null;
                    if (backgroundColor !== 'none') {
                        baseplateRgb = LEGO_COLORS[backgroundColor];
                    }
                    applyDithering(processedData, targetWidth, targetHeight, baseplateRgb);
                    
                    for (let y = 0; y < targetHeight; y++) {
                        const row = [];
                        for (let x = 0; x < targetWidth; x++) {
                            const i = (y * targetWidth + x) * 4;
                            const r = processedPixels[i];
                            const g = processedPixels[i + 1];
                            const b = processedPixels[i + 2];
                            
                            if (backgroundMask && backgroundMask[y][x]) {
                                row.push(null);
                                continue;
                            }
                            
                            const { name } = findClosestLegoColor(r, g, b);
                            
                            if (backgroundColor !== 'none' && name === backgroundColor) {
                                row.push(null);
                            } else {
                                colorCounts[name] = (colorCounts[name] || 0) + 1;
                                row.push(name);
                            }
                        }
                        tileMap.push(row);
                    }
                } else {
                    for (let y = 0; y < targetHeight; y++) {
                        const row = [];
                        for (let x = 0; x < targetWidth; x++) {
                            const i = (y * targetWidth + x) * 4;
                            const r = processedPixels[i];
                            const g = processedPixels[i + 1];
                            const b = processedPixels[i + 2];

                            if (backgroundMask && backgroundMask[y][x]) {
                                row.push(null);
                                continue;
                            }

                            const { name, rgb } = findClosestLegoColor(r, g, b);

                            processedPixels[i] = rgb[0];
                            processedPixels[i + 1] = rgb[1];
                            processedPixels[i + 2] = rgb[2];

                            if (backgroundColor !== 'none' && name === backgroundColor) {
                                row.push(null);
                            } else {
                                colorCounts[name] = (colorCounts[name] || 0) + 1;
                                row.push(name);
                            }
                        }
                        tileMap.push(row);
                    }
                }

                legoCtx.putImageData(processedData, 0, 0);

                if (showGrid) {
                    drawGrid(originalCanvas, targetWidth, targetHeight);
                    drawGrid(legoCanvas, targetWidth, targetHeight);
                }

                // Update stats
                const actualTileCount = Object.values(colorCounts).reduce((sum, count) => sum + count, 0);
                const totalGridSpaces = targetWidth * targetHeight;
                const physicalWidthCm = (targetWidth * 8 / 10).toFixed(1);
                const physicalHeightCm = (targetHeight * 8 / 10).toFixed(1);

                document.getElementById('dimensions').textContent = `${targetWidth}√ó${targetHeight}`;
                document.getElementById('totalTiles').textContent = (removeBackground || backgroundColor !== 'none')
                    ? `${actualTileCount.toLocaleString()} (${totalGridSpaces.toLocaleString()} grid spaces)` 
                    : actualTileCount.toLocaleString();
                document.getElementById('uniqueColors').textContent = Object.keys(colorCounts).length;
                document.getElementById('physicalSize').textContent = `${physicalWidthCm}√ó${physicalHeightCm} cm`;

                // Update Forge Theory stats
                updateForgeTheoryStats();

                // Display color breakdown
                const colorList = document.getElementById('colorList');
                const sortedColors = Object.entries(colorCounts).sort((a, b) => b[1] - a[1]);

                colorList.innerHTML = sortedColors.map(([name, count]) => {
                    const rgb = LEGO_COLORS[name];
                    return `
                        <div class="color-item">
                            <div class="color-swatch" style="background: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]});"></div>
                            <div class="color-info">
                                <span class="color-name">${name}</span>
                                <span class="color-count">${count}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                previewSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

                downloadBtn.style.display = 'block';
                exportPartsBtn.style.display = 'block';
                exportInstructionsBtn.style.display = 'block';

                // Hide loading spinner
                loadingOverlay.classList.remove('active');
            }, 50);
        }

        // Theme Toggle Logic
        const toggleBtn = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const html = document.documentElement;

        // Initialize theme
        const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        html.setAttribute('data-theme', savedTheme);
        if(themeIcon) themeIcon.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';

        toggleBtn.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeIcon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        });

        // PWA installation
        if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').catch(() => {
                    console.log('Service worker registration optional');
                });
            });
        }

        // Falling Bricks Animation (Piling)
        const brickContainer = document.getElementById('falling-bricks-container');
        const brickColors = ['#FF6B35', '#004E89', '#FFD700', '#28A745', '#DC3545', '#6C757D', '#17A2B8'];
        const GRID_SIZE = 20;
        let numCols = Math.ceil(window.innerWidth / GRID_SIZE);
        let colHeights = new Array(numCols).fill(0);

        window.addEventListener('resize', () => {
            numCols = Math.ceil(window.innerWidth / GRID_SIZE);
            colHeights = new Array(numCols).fill(0);
            brickContainer.innerHTML = '';
        });

        function createBrick() {
            if (document.hidden || window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

            const units = Math.floor(Math.random() * 3) + 1;
            const width = units * GRID_SIZE;
            const height = 20;

            const maxCol = numCols - units;
            if (maxCol < 0) return;
            const startCol = Math.floor(Math.random() * (maxCol + 1));

            let currentStackHeight = 0;
            for (let i = 0; i < units; i++) {
                currentStackHeight = Math.max(currentStackHeight, colHeights[startCol + i]);
            }

            if (currentStackHeight > window.innerHeight) return;

            for (let i = 0; i < units; i++) {
                colHeights[startCol + i] = currentStackHeight + height;
            }

            const targetTop = window.innerHeight - currentStackHeight - height;

            const brick = document.createElement('div');
            brick.classList.add('falling-brick');
            brick.style.width = (width - 2) + 'px';
            brick.style.height = (height - 2) + 'px';
            brick.style.left = (startCol * GRID_SIZE) + 'px';
            brick.style.backgroundColor = brickColors[Math.floor(Math.random() * brickColors.length)];
            
            brickContainer.appendChild(brick);

            brick.animate([
                { transform: `translateY(${-50}px)` },
                { transform: `translateY(${targetTop}px)` }
            ], { duration: 1000 + Math.random() * 1000, easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', fill: 'forwards' });
        }
        setInterval(createBrick, 200);
    </script>
</body>
</html>